{
  "title": "learn Understanding Python Decorators",
  "slug": "level-python-decorators",
  "order": 6,
  "description": "A practical guide to understanding and using decorators in Python.",
  "body": {
    "raw": "\n## What are Decorators?\n\nIn Python, a decorator is a design pattern that allows you to add new functionality to an existing object (like a function or method) without modifying its structure. Decorators are a form of metaprogramming, where a part of the program tries to modify another part of the program at compile time. They are often used for logging, access control, instrumentation, and more.\n\n## Basic Decorator Syntax\n\nA decorator is typically a function that takes another function as an argument (the decorated function), adds some functionality, and then returns another function.\n\n```python\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"Something is happening before the function is called.\")\n        result = func(*args, **kwargs)\n        print(\"Something is happening after the function is called.\")\n        return result\n    return wrapper\n\n@my_decorator\ndef say_hello(name):\n    print(f\"Hello, {name}!\")\n\nsay_hello(\"World\")\n```\n\nThis will output:\n```\nSomething is happening before the function is called.\nHello, World!\nSomething is happening after the function is called.\n```\n\n## Using `functools.wraps`\n\nWhen you use decorators, you are essentially replacing the original function with the wrapper function. This can obscure the original function's metadata (like its name, docstring, etc.). The `functools.wraps` decorator can be used to preserve this metadata.\n\n```python\nimport functools\n\ndef my_better_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(\"Wrapper executing pre-call actions.\")\n        value = func(*args, **kwargs)\n        print(\"Wrapper executing post-call actions.\")\n        return value\n    return wrapper\n\n@my_better_decorator\ndef greet(name):\n    \"\"\"Greets a person.\"\"\"\n    return f\"Greetings, {name}!\"\n\nprint(greet(\"Pythonista\"))\nprint(greet.__name__) # Output: greet (thanks to @functools.wraps)\nprint(greet.__doc__)  # Output: Greets a person. (thanks to @functools.wraps)\n```\n\nDecorators are a very useful tool in Python for writing cleaner and more modular code.\n",
    "html": "<h2>What are Decorators?</h2>\n<p>In Python, a decorator is a design pattern that allows you to add new functionality to an existing object (like a function or method) without modifying its structure. Decorators are a form of metaprogramming, where a part of the program tries to modify another part of the program at compile time. They are often used for logging, access control, instrumentation, and more.</p>\n<h2>Basic Decorator Syntax</h2>\n<p>A decorator is typically a function that takes another function as an argument (the decorated function), adds some functionality, and then returns another function.</p>\n<pre><code class=\"language-python\">def my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"Something is happening before the function is called.\")\n        result = func(*args, **kwargs)\n        print(\"Something is happening after the function is called.\")\n        return result\n    return wrapper\n\n@my_decorator\ndef say_hello(name):\n    print(f\"Hello, {name}!\")\n\nsay_hello(\"World\")\n</code></pre>\n<p>This will output:</p>\n<pre><code>Something is happening before the function is called.\nHello, World!\nSomething is happening after the function is called.\n</code></pre>\n<h2>Using <code>functools.wraps</code></h2>\n<p>When you use decorators, you are essentially replacing the original function with the wrapper function. This can obscure the original function's metadata (like its name, docstring, etc.). The <code>functools.wraps</code> decorator can be used to preserve this metadata.</p>\n<pre><code class=\"language-python\">import functools\n\ndef my_better_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(\"Wrapper executing pre-call actions.\")\n        value = func(*args, **kwargs)\n        print(\"Wrapper executing post-call actions.\")\n        return value\n    return wrapper\n\n@my_better_decorator\ndef greet(name):\n    \"\"\"Greets a person.\"\"\"\n    return f\"Greetings, {name}!\"\n\nprint(greet(\"Pythonista\"))\nprint(greet.__name__) # Output: greet (thanks to @functools.wraps)\nprint(greet.__doc__)  # Output: Greets a person. (thanks to @functools.wraps)\n</code></pre>\n<p>Decorators are a very useful tool in Python for writing cleaner and more modular code.</p>"
  },
  "_id": "tutorials/python/python-decorators.md",
  "_raw": {
    "sourceFilePath": "tutorials/python/python-decorators.md",
    "sourceFileName": "python-decorators.md",
    "sourceFileDir": "tutorials/python",
    "contentType": "markdown",
    "flattenedPath": "tutorials/python/python-decorators"
  },
  "type": "TutorialPost",
  "url": "/tutorial/python/level-python-decorators",
  "language": "python"
}